{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Das 'littleyoda-DCC-Decoder' Projekt ist ein flexibles Framework f\u00fcr Modelleisenbahnen-Decoder und Steuerung. Basiserend auf einem ESP8266 Mikroprozessor, kann die Software DCC-Befehle auswerten und kann \u00fcber eine WLAN-Schnittstelle kommunizieren. Es k\u00f6nnen verschiedene Aktoren angesteuert werden. Z.B. Weichenmotoren LED Servos DC Motoren Standard-DCC-Decoder Genutzt wird diese Framework f\u00fcr: Lokdekoder Funktionsdekoder Weichendekoder DCC Generatoren Gleisbildstellwerk Da der ESP8266 via WLAN kommunizieren kann, entstehen hierdurch sehr viele interessante Anwendungsf\u00e4lle , die kaufbare Produkte nicht bieten. Aus rechtlichen Gr\u00fcnden darf ich fertige Hardware nicht verkaufen. F\u00fcr einige Anwendungsf\u00e4lle k\u00f6nnen jedoch fertige Bauteile gekauft werden, die danach nur noch verbunden werden m\u00fcssen. Fragen sind am besten im meinem Forum aufgehoben. Wenn euch meine L\u00f6sung gef\u00e4llt, w\u00fcrde ich mich \u00fcber eine Anerkennung freuen.","title":"Home"},{"location":"FAQ/","text":"Nutzung einer z21/Z21 Wieviele Ger\u00e4te/Decoder kann die z21 verwalten Die genaue Anzahl ist unbekannt. Roco gibt teilweise eine maximale Anzahl von 10 Ger\u00e4ten per WLAN an. Jedes Endger\u00e4t (z21-App/WLan-Maus) und jeder Decoder, der per WLAN kommuniziert, z\u00e4hlt als ein Ger\u00e4t. Rocrail kann als Software-L\u00f6sung dienen, um diese Einschr\u00e4nkung zu umgehen. Hardware Unterst\u00fctzung ESP32 Eine Unterst\u00fctzung des ESP32 ist begonnen, wird aber noch Zeit in Anspruch nehmen.","title":"FAQ"},{"location":"FAQ/#nutzung-einer-z21z21","text":"","title":"Nutzung einer z21/Z21"},{"location":"FAQ/#wieviele-geratedecoder-kann-die-z21-verwalten","text":"Die genaue Anzahl ist unbekannt. Roco gibt teilweise eine maximale Anzahl von 10 Ger\u00e4ten per WLAN an. Jedes Endger\u00e4t (z21-App/WLan-Maus) und jeder Decoder, der per WLAN kommuniziert, z\u00e4hlt als ein Ger\u00e4t. Rocrail kann als Software-L\u00f6sung dienen, um diese Einschr\u00e4nkung zu umgehen.","title":"Wieviele Ger\u00e4te/Decoder kann die z21 verwalten"},{"location":"FAQ/#hardware","text":"","title":"Hardware"},{"location":"FAQ/#unterstutzung-esp32","text":"Eine Unterst\u00fctzung des ESP32 ist begonnen, wird aber noch Zeit in Anspruch nehmen.","title":"Unterst\u00fctzung ESP32"},{"location":"Anwendung/DCC-Generator/","text":"DCC Generierung In diesem Fall erzeugt der ESP8266 mit Hilfe einer H-Bridge ein DCC-Signal mit welchem ein normaler DCC-Decoder angesteuert werden kann. Die Befehle k\u00f6nnen z.B. per WLAN an den ESP8266 verschickt werden und dieser generiert ein DCC-Signal f\u00fcr eine H-Bridge. Mit diesem DCC-Signal wird dann ein klassischer DCC-Decoder angesteuert, der dann den Motor regelt. Z21 App oder Wlan-Maus => WLAN => ESP8266 => H-Bridge => DCC-Signal => DCC-Decoder => Motor / Sound Es ist darauf zu achten, dass die H-Bridge ausreichend dimensioniert ist. Im Spassbahn-Forum gab es die Diskussion, ob die H-Bridge \u00fcberhaupt so stark sein muss oder ob es nicht ausreichen w\u00fcrde, den Decoder \u00fcber den PowerPack-Eingang zu versorgen und eine \"schwache\" H-Bridge zu nutzen. (Diesen Test \u00fcberlasse ich gerne anderen Personen) Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Die Lok erh\u00e4lt sich in diesem Fall praktisch wie eine Lok, die ihre Befehle \u00fcber die Schienen erh\u00e4lt. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden. Warum dieser Ansatz? Zwei Gr\u00fcnde (wovon ich aber nur den ersten wirklich teile) Nutzung von Sound Obwohl es auch m\u00f6glich w\u00e4re, Sound \u00fcber den ESP8266 abzuspielen, ist die Nutzung eines klassischen DCC-Sounddecoder doch sehr viel einfacher. bessere Qualit\u00e4t der Motoransteuerung Bei der Nutzung einer einfachen H-Bridge zur Motorsteuerung wird meistens nur ein einfaches lastunabh\u00e4ngiges PWM-Signal generiert. Hier sind die DCC-Decoder deutlich weiter. Funktionsumfang Generiert ein DCC-Signal mit 128 Fahrstufen 28 Funktionstasten Anwendungsf\u00e4lle L298N DRV8870 Technischer Hintergrund SPI Das Signal wird im ESP8266 \u00fcber den SPI-Ausgang erzeugt. Dieser Ausgang hat einen Hardware-Buffer, so dass sichergestellt ist, dass das DCC-Timing eingehalten wird. Es wird also immer ein DCC-Paket erzeugt, in das notwendige SPI-Format gewandelt und anschlie\u00dfend in den Hardware-Buffer geschrieben. Bei den ersten Tests stellt sich heraus, dass die SPI-Library beim Senden so lange blockiert, bis das Paket komplett verschickt wurde. Au\u00dferdem belegte die Library direkt drei GPIO f\u00fcr MISO, MOSI, SCK. Aus diesem Grund wurde die SPI-Library an die Bed\u00fcrfnisse dieses Frameworks angepasst. Jetzt wird im einfachsten Fall nur noch ein Pin (13 bzw. D7) genutzt. Dieser Pin ist fest, da er der einzige nutzbare Pin mit Hardware-m\u00e4\u00dfiger SPI Unterst\u00fctzung ist. \"Halbes\" DCC An D7 liegt aber nur eine Art \"positive Halbwelle\" des DCC-Signales an. Da das DCC-Signal aber eine Wechselspannung ist, wird auch noch \"negative Halbwelle\" ben\u00f6tigt. Diese Halbwelle wird aus dem Signal von D7 durch einen Transistor erzeugt, der das Signal invertiert (siehe zweites Signal). Es werden DCC-Paketen f\u00fcr die Geschwindigkeit und Richtung erzeugt, sowie Pakete f\u00fcr den Zustand von F0 bis F28. Prototypen Da Julian Zimmermann, der diesen Ansatz im Spassbahn-Forum vorgestellt hatte, keine Zeit hatte ihn zu verfeinern und mich das Technische interessierte, habe ich ihn um die Sourcen gebeten, damit ich es in mein Framework integrieren kann. Nach einigen frustrierenden Abenden habe ich einen Prototypen zum laufen gebracht: Der Motorblock reagierte endlich auf die generierten DCC-Befehle. Entwicklungsgeschichte Aus diesem Prototypen haben sich die oben genannten Schaltungen entwickelt.","title":"Einf\u00fchrung"},{"location":"Anwendung/DCC-Generator/#dcc-generierung","text":"In diesem Fall erzeugt der ESP8266 mit Hilfe einer H-Bridge ein DCC-Signal mit welchem ein normaler DCC-Decoder angesteuert werden kann. Die Befehle k\u00f6nnen z.B. per WLAN an den ESP8266 verschickt werden und dieser generiert ein DCC-Signal f\u00fcr eine H-Bridge. Mit diesem DCC-Signal wird dann ein klassischer DCC-Decoder angesteuert, der dann den Motor regelt. Z21 App oder Wlan-Maus => WLAN => ESP8266 => H-Bridge => DCC-Signal => DCC-Decoder => Motor / Sound Es ist darauf zu achten, dass die H-Bridge ausreichend dimensioniert ist. Im Spassbahn-Forum gab es die Diskussion, ob die H-Bridge \u00fcberhaupt so stark sein muss oder ob es nicht ausreichen w\u00fcrde, den Decoder \u00fcber den PowerPack-Eingang zu versorgen und eine \"schwache\" H-Bridge zu nutzen. (Diesen Test \u00fcberlasse ich gerne anderen Personen) Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Die Lok erh\u00e4lt sich in diesem Fall praktisch wie eine Lok, die ihre Befehle \u00fcber die Schienen erh\u00e4lt. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden.","title":"DCC Generierung"},{"location":"Anwendung/DCC-Generator/#warum-dieser-ansatz","text":"Zwei Gr\u00fcnde (wovon ich aber nur den ersten wirklich teile) Nutzung von Sound Obwohl es auch m\u00f6glich w\u00e4re, Sound \u00fcber den ESP8266 abzuspielen, ist die Nutzung eines klassischen DCC-Sounddecoder doch sehr viel einfacher. bessere Qualit\u00e4t der Motoransteuerung Bei der Nutzung einer einfachen H-Bridge zur Motorsteuerung wird meistens nur ein einfaches lastunabh\u00e4ngiges PWM-Signal generiert. Hier sind die DCC-Decoder deutlich weiter.","title":"Warum dieser Ansatz?"},{"location":"Anwendung/DCC-Generator/#funktionsumfang","text":"Generiert ein DCC-Signal mit 128 Fahrstufen 28 Funktionstasten","title":"Funktionsumfang"},{"location":"Anwendung/DCC-Generator/#anwendungsfalle","text":"L298N DRV8870","title":"Anwendungsf\u00e4lle"},{"location":"Anwendung/DCC-Generator/#technischer-hintergrund","text":"","title":"Technischer Hintergrund"},{"location":"Anwendung/DCC-Generator/#spi","text":"Das Signal wird im ESP8266 \u00fcber den SPI-Ausgang erzeugt. Dieser Ausgang hat einen Hardware-Buffer, so dass sichergestellt ist, dass das DCC-Timing eingehalten wird. Es wird also immer ein DCC-Paket erzeugt, in das notwendige SPI-Format gewandelt und anschlie\u00dfend in den Hardware-Buffer geschrieben. Bei den ersten Tests stellt sich heraus, dass die SPI-Library beim Senden so lange blockiert, bis das Paket komplett verschickt wurde. Au\u00dferdem belegte die Library direkt drei GPIO f\u00fcr MISO, MOSI, SCK. Aus diesem Grund wurde die SPI-Library an die Bed\u00fcrfnisse dieses Frameworks angepasst. Jetzt wird im einfachsten Fall nur noch ein Pin (13 bzw. D7) genutzt. Dieser Pin ist fest, da er der einzige nutzbare Pin mit Hardware-m\u00e4\u00dfiger SPI Unterst\u00fctzung ist.","title":"SPI"},{"location":"Anwendung/DCC-Generator/#halbes-dcc","text":"An D7 liegt aber nur eine Art \"positive Halbwelle\" des DCC-Signales an. Da das DCC-Signal aber eine Wechselspannung ist, wird auch noch \"negative Halbwelle\" ben\u00f6tigt. Diese Halbwelle wird aus dem Signal von D7 durch einen Transistor erzeugt, der das Signal invertiert (siehe zweites Signal). Es werden DCC-Paketen f\u00fcr die Geschwindigkeit und Richtung erzeugt, sowie Pakete f\u00fcr den Zustand von F0 bis F28.","title":"\"Halbes\" DCC"},{"location":"Anwendung/DCC-Generator/#prototypen","text":"Da Julian Zimmermann, der diesen Ansatz im Spassbahn-Forum vorgestellt hatte, keine Zeit hatte ihn zu verfeinern und mich das Technische interessierte, habe ich ihn um die Sourcen gebeten, damit ich es in mein Framework integrieren kann. Nach einigen frustrierenden Abenden habe ich einen Prototypen zum laufen gebracht: Der Motorblock reagierte endlich auf die generierten DCC-Befehle. Entwicklungsgeschichte Aus diesem Prototypen haben sich die oben genannten Schaltungen entwickelt.","title":"Prototypen"},{"location":"Anwendung/DCC-Generator/DCC_Generator_DRV8870/","text":"DCC Generator mit Hilfe einer DRV8870-Platine Dieses Dokument beschreibt den DCC Generators auf Basis einer selbst entwickelten Platine mit einem DRV8870 und einem ESP-M3 (aus der ESP8266-Serie). Schaltplan / Aufbau Auf der Platine werden als Hauptkomponenten ein ESP-M3 und ein DRV8870 gel\u00f6tet. Die Platine ist inkl. ESP-M3 4,3 x 2,2 cm gro\u00df. Ansteuerung Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden. Nutzungsbeispeile Hier beispielhaft in einer Spur 0 Lok verbaut. Als Decoder wird ein ESU LokSound 4 genutzt. Copyright by Ralf Stassrast Technischer Hintergrund siehe DCC Generator","title":"DRV8870"},{"location":"Anwendung/DCC-Generator/DCC_Generator_DRV8870/#dcc-generator-mit-hilfe-einer-drv8870-platine","text":"Dieses Dokument beschreibt den DCC Generators auf Basis einer selbst entwickelten Platine mit einem DRV8870 und einem ESP-M3 (aus der ESP8266-Serie).","title":"DCC Generator mit Hilfe einer DRV8870-Platine"},{"location":"Anwendung/DCC-Generator/DCC_Generator_DRV8870/#schaltplan-aufbau","text":"Auf der Platine werden als Hauptkomponenten ein ESP-M3 und ein DRV8870 gel\u00f6tet. Die Platine ist inkl. ESP-M3 4,3 x 2,2 cm gro\u00df.","title":"Schaltplan / Aufbau"},{"location":"Anwendung/DCC-Generator/DCC_Generator_DRV8870/#ansteuerung","text":"Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden.","title":"Ansteuerung"},{"location":"Anwendung/DCC-Generator/DCC_Generator_DRV8870/#nutzungsbeispeile","text":"Hier beispielhaft in einer Spur 0 Lok verbaut. Als Decoder wird ein ESU LokSound 4 genutzt. Copyright by Ralf Stassrast","title":"Nutzungsbeispeile"},{"location":"Anwendung/DCC-Generator/DCC_Generator_DRV8870/#technischer-hintergrund","text":"siehe DCC Generator","title":"Technischer Hintergrund"},{"location":"Anwendung/DCC-Generator/DCC_Generator_L298N/","text":"DCC Generator mit Hilfe einer L298N-Platine Dieses Dokument beschreibt wohl den einfachsten Aufbau eines DCC Generators . Schaltplan / Aufbau Die aktuelle Schaltung besteht aus einem NodeMCU (D1 oder \u00e4hnliches w\u00fcrde nat\u00fcrlich auch gehen), einer L298N Motor Platine, einem NPN-Transitor (2N2222A), zwei 1k Ohm Widerst\u00e4nde und einem Akku-Pack. Nat\u00fcrlich k\u00f6nnen auch andere H-Bridge genutzt werden. Hier muss ggf. noch eine unabh\u00e4ngig 5V Versorgung hinzugef\u00fcgt werden. Ansteuerung Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden. Nutzungsbeispeile Zoltan hat diesen Ansatz in seiner Harzkamel eingebaut. Im Garten Bahn Forum hat er den Einbau dokumentiert . Copyright by Zoltan Egyed Copyright by Zoltan Egyed Bestandteile: - Nodemcu-Board - L293D-Platine - Widerst\u00e4nde + Transistor - 4 16850 Akkus - ESU LokSound 4 XL Technischer Hintergrund siehe DCC Generator","title":"L298N"},{"location":"Anwendung/DCC-Generator/DCC_Generator_L298N/#dcc-generator-mit-hilfe-einer-l298n-platine","text":"Dieses Dokument beschreibt wohl den einfachsten Aufbau eines DCC Generators .","title":"DCC Generator mit Hilfe einer L298N-Platine"},{"location":"Anwendung/DCC-Generator/DCC_Generator_L298N/#schaltplan-aufbau","text":"Die aktuelle Schaltung besteht aus einem NodeMCU (D1 oder \u00e4hnliches w\u00fcrde nat\u00fcrlich auch gehen), einer L298N Motor Platine, einem NPN-Transitor (2N2222A), zwei 1k Ohm Widerst\u00e4nde und einem Akku-Pack. Nat\u00fcrlich k\u00f6nnen auch andere H-Bridge genutzt werden. Hier muss ggf. noch eine unabh\u00e4ngig 5V Versorgung hinzugef\u00fcgt werden.","title":"Schaltplan / Aufbau"},{"location":"Anwendung/DCC-Generator/DCC_Generator_L298N/#ansteuerung","text":"Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden.","title":"Ansteuerung"},{"location":"Anwendung/DCC-Generator/DCC_Generator_L298N/#nutzungsbeispeile","text":"Zoltan hat diesen Ansatz in seiner Harzkamel eingebaut. Im Garten Bahn Forum hat er den Einbau dokumentiert . Copyright by Zoltan Egyed Copyright by Zoltan Egyed Bestandteile: - Nodemcu-Board - L293D-Platine - Widerst\u00e4nde + Transistor - 4 16850 Akkus - ESU LokSound 4 XL","title":"Nutzungsbeispeile"},{"location":"Anwendung/DCC-Generator/DCC_Generator_L298N/#technischer-hintergrund","text":"siehe DCC Generator","title":"Technischer Hintergrund"},{"location":"Anwendung/Lokdekoder/Lokdekoder_BTS7960/","text":"Lokdekoder (BTS7960) F\u00fcr diesen Lokdekoder wird eine fertige H-Bridge vom Typ BTS7960 genutzt. Diese H-Bridge ist ausreichend, um z.B. eine Piko-Lok mit zwei Motoren anzutreiben. Ansteuerung Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden. Schlatplan / Aufbau Technischer Hintergrund Ich habe den Aufbau \u00fcber einen Step-Up Regler (Ausgang: ~17V) gew\u00e4hlt, damit ich auch andere Akkupacks anschlie\u00dfen kann, die niedrige Spannungen liefern. Testweise habe ich es mit einer 5V USB Powerbank getestet. Hierbei \u00fcberhitzt der ausgew\u00e4hlte Step-Up-Regler. Sollte jemand den 5V Weg gehen wollen, k\u00f6nnte man K\u00fchlk\u00f6per probieren. Ich vermute aber, dass man einen anderen Step-Up-Regler ausw\u00e4hlen m\u00fcsste. Je nach Spannung des Akku kann der Step-Up Regler aber auch ersatzlos entfallen. Bei den Akkus habe ich mich bewusst f\u00fcr gesch\u00fctzte Akkus entschieden und kann dadurch eine zus\u00e4tzliche Schutz- und Entladeschaltung verzichten. Da das Thema F\u00e4lschung von Akkus ein ziemliches Problem darstellt, sollte man bei vertrauensw\u00fcrdigen Lieferanten kaufen.","title":"BTS7960"},{"location":"Anwendung/Lokdekoder/Lokdekoder_BTS7960/#lokdekoder-bts7960","text":"F\u00fcr diesen Lokdekoder wird eine fertige H-Bridge vom Typ BTS7960 genutzt. Diese H-Bridge ist ausreichend, um z.B. eine Piko-Lok mit zwei Motoren anzutreiben.","title":"Lokdekoder (BTS7960)"},{"location":"Anwendung/Lokdekoder/Lokdekoder_BTS7960/#ansteuerung","text":"Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden.","title":"Ansteuerung"},{"location":"Anwendung/Lokdekoder/Lokdekoder_BTS7960/#schlatplan-aufbau","text":"","title":"Schlatplan / Aufbau"},{"location":"Anwendung/Lokdekoder/Lokdekoder_BTS7960/#technischer-hintergrund","text":"Ich habe den Aufbau \u00fcber einen Step-Up Regler (Ausgang: ~17V) gew\u00e4hlt, damit ich auch andere Akkupacks anschlie\u00dfen kann, die niedrige Spannungen liefern. Testweise habe ich es mit einer 5V USB Powerbank getestet. Hierbei \u00fcberhitzt der ausgew\u00e4hlte Step-Up-Regler. Sollte jemand den 5V Weg gehen wollen, k\u00f6nnte man K\u00fchlk\u00f6per probieren. Ich vermute aber, dass man einen anderen Step-Up-Regler ausw\u00e4hlen m\u00fcsste. Je nach Spannung des Akku kann der Step-Up Regler aber auch ersatzlos entfallen. Bei den Akkus habe ich mich bewusst f\u00fcr gesch\u00fctzte Akkus entschieden und kann dadurch eine zus\u00e4tzliche Schutz- und Entladeschaltung verzichten. Da das Thema F\u00e4lschung von Akkus ein ziemliches Problem darstellt, sollte man bei vertrauensw\u00fcrdigen Lieferanten kaufen.","title":"Technischer Hintergrund"},{"location":"Anwendung/Lokdekoder/Lokdekoder_DRV8870/","text":"Lokdekoder (DRV8870) Dieser Dekoder ist wahlweise mit einer oder zwei H-Bridge vom Typ DRV8870 ausgestattet und sollte somit auch f\u00fcr Piko-Loks mit zwei Motoren geeignet sein. Weitere Informationen Funktionsumfang 2x DRV8870 mit je max 2A 8x unverst\u00e4rkte Ausg\u00e4nge 8x verst\u00e4rkte Ausg\u00e4nge Ansteuerung Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden. Schlatplan / Aufbau Technischer Hintergrund Um die Anzahl der Ausg\u00e4nge zu erh\u00f6hen, wird ein Port-Expander (MCP23017) genutzt der via i\u00b2C an den ESP8266 angeschlossen ist. 8 Ausg\u00e4nge des MCP23017 steuern einen ULN2803A an. Somit stehen 8 \"unverst\u00e4rkte\" und 8 \"verst\u00e4rkte\" Ausg\u00e4nge zur Verf\u00fcgung.","title":"DRV8870"},{"location":"Anwendung/Lokdekoder/Lokdekoder_DRV8870/#lokdekoder-drv8870","text":"Dieser Dekoder ist wahlweise mit einer oder zwei H-Bridge vom Typ DRV8870 ausgestattet und sollte somit auch f\u00fcr Piko-Loks mit zwei Motoren geeignet sein. Weitere Informationen","title":"Lokdekoder (DRV8870)"},{"location":"Anwendung/Lokdekoder/Lokdekoder_DRV8870/#funktionsumfang","text":"2x DRV8870 mit je max 2A 8x unverst\u00e4rkte Ausg\u00e4nge 8x verst\u00e4rkte Ausg\u00e4nge","title":"Funktionsumfang"},{"location":"Anwendung/Lokdekoder/Lokdekoder_DRV8870/#ansteuerung","text":"Die L\u00f6sung kann \u00fcber 2 Wege gesteuert werden: Der Decoder kann sich \u00fcber WLAN mit einer Z21 verbinden und von dort die Befehle erhalten. Der Decoder kann eine Z21 simulieren und ein WLAN-Netz aufspannen. Anschlie\u00dfend kann man den Decoder direkt und ohne die Notwendigkeit einer Z21 ansteuern. Die Z21-App oder die WLAN-Maus kann zur Steuerung genutzt werden.","title":"Ansteuerung"},{"location":"Anwendung/Lokdekoder/Lokdekoder_DRV8870/#schlatplan-aufbau","text":"","title":"Schlatplan / Aufbau"},{"location":"Anwendung/Lokdekoder/Lokdekoder_DRV8870/#technischer-hintergrund","text":"Um die Anzahl der Ausg\u00e4nge zu erh\u00f6hen, wird ein Port-Expander (MCP23017) genutzt der via i\u00b2C an den ESP8266 angeschlossen ist. 8 Ausg\u00e4nge des MCP23017 steuern einen ULN2803A an. Somit stehen 8 \"unverst\u00e4rkte\" und 8 \"verst\u00e4rkte\" Ausg\u00e4nge zur Verf\u00fcgung.","title":"Technischer Hintergrund"},{"location":"Anwendung/Weichendekoder/USECASE_Weichendekoder/","text":"Weichendecoder Motiviert durch die hohen Kosten von Weichendecodern und dem Interesse an dem ESP8266-Mikroprozessor habe ich begonnen einen Weichendecoder selber zu bauen. Die aktuelle Version findet Platz auf einer 5 x 5 cm gro\u00dfen Platinen und kann die Befehle entweder per DCC \u00fcber die Schienen oder aber via WLAN die Befehle direkt von der Z21 erhalten. Alternativ ist der Weichendekoder auch via Browser steuerbar. Ansteuerbar sind jeweils zwei LGB/PIKO/EPL Weichen. Der Decoder kann entweder \u00fcber Schienenstorm oder aber \u00fcber eine externe Stromquelle versorgt werden. Die Spannung sollte zwischen 7 und 24V betragen. Aktueller Entwicklungsststand Die Platine ist jetzt schon mehr als 1 1/2 Jahre (Stand: Jan 2018) im Einsatz. Hat den Forst von zwei Wintern \u00fcberlebt. Hardware Hauptkomponenten sind ein ESP8266 zur Steuerung und ein Motortreiber vom Typ L293D. Artikel Anzahl Gesamtpreis \u20ac Platine 1 1,50 NodeMCU V2 1 2,90 Link L293D 1 0,35 Link B80C1500 1 0,30 Link Anschl\u00fcsse 4 0,27 Link Spannungsregler 1 0,60 Link 6N136 1 0,37 Link 1N4004 1 0,04 Link 220uF 35V 1 0,04 Link 1,5 Kohm 1 0,01 10 Kohm 5 0,05 15 pin Buchsenleiste 2 0,24 Link Sockel 16 pin 1 0,09 Link Geh\u00e4use 85x58x35 1 1,50 Link","title":"Weichendekoder"},{"location":"Anwendung/Weichendekoder/USECASE_Weichendekoder/#weichendecoder","text":"Motiviert durch die hohen Kosten von Weichendecodern und dem Interesse an dem ESP8266-Mikroprozessor habe ich begonnen einen Weichendecoder selber zu bauen. Die aktuelle Version findet Platz auf einer 5 x 5 cm gro\u00dfen Platinen und kann die Befehle entweder per DCC \u00fcber die Schienen oder aber via WLAN die Befehle direkt von der Z21 erhalten. Alternativ ist der Weichendekoder auch via Browser steuerbar. Ansteuerbar sind jeweils zwei LGB/PIKO/EPL Weichen. Der Decoder kann entweder \u00fcber Schienenstorm oder aber \u00fcber eine externe Stromquelle versorgt werden. Die Spannung sollte zwischen 7 und 24V betragen.","title":"Weichendecoder"},{"location":"Anwendung/Weichendekoder/USECASE_Weichendekoder/#aktueller-entwicklungsststand","text":"Die Platine ist jetzt schon mehr als 1 1/2 Jahre (Stand: Jan 2018) im Einsatz. Hat den Forst von zwei Wintern \u00fcberlebt.","title":"Aktueller Entwicklungsststand"},{"location":"Anwendung/Weichendekoder/USECASE_Weichendekoder/#hardware","text":"Hauptkomponenten sind ein ESP8266 zur Steuerung und ein Motortreiber vom Typ L293D. Artikel Anzahl Gesamtpreis \u20ac Platine 1 1,50 NodeMCU V2 1 2,90 Link L293D 1 0,35 Link B80C1500 1 0,30 Link Anschl\u00fcsse 4 0,27 Link Spannungsregler 1 0,60 Link 6N136 1 0,37 Link 1N4004 1 0,04 Link 220uF 35V 1 0,04 Link 1,5 Kohm 1 0,01 10 Kohm 5 0,05 15 pin Buchsenleiste 2 0,24 Link Sockel 16 pin 1 0,09 Link Geh\u00e4use 85x58x35 1 1,50 Link","title":"Hardware"},{"location":"Entwicklung/DebugSerial/","text":"Debug \u00fcber die serielle Schnittstelle Wenn man den ESP8266 \u00fcber ein USB-Kabel mit dem Computer verbindet, kann auf dem ESP8266 \u00fcber die serielle Schnittstelle zugegriffen werden. Als Baudrate ist 115200 einzustellen. Im laufenden Betrieb werden zum einen die Logmeldeungen \u00fcber die serielle Schnittstelle ausgegeben, zum anderen stehen verschiedene Befehle im Debugmodus zur Verf\u00fcgung. Der Debugsmodus wird durch das Senden der Zeichenfolge 'debug' aktiviert. Anschlie\u00dfend k\u00f6nnen die Befehle \u00fcber einzelne Buchstaben ausgel\u00f6st werdem. Gro\u00df- und Kleinschreibung sind relevant. Folgende Befehle sind implementiert: 'd': Zeigt diverse Informationen \u00fcber den ESP8266 inkl. Speicher und Wifi-Status an. 'r': Startet den ESP8266 neu. Dieser Weg funktioniert nicht, wenn der ESP8266 gerade neu geflasht wurde. 'D': l\u00f6scht das aktuelle Konfig-File. Nach dem Neustarten des ESP8266 ist er wieder \u00fcber das WLAN-Netz \"Hallo World\" und der IP-Adresse 192.168.4.1 erreichbar. 'a': Aktiviert den AccessPoint-Modus unabh\u00e4ngig vom Konfig-File. Die genutzte IP-Adresse kann \u00fcber die 'd'-Funktion angezeigt werden. 'c': Anzeige des Konfig-Files","title":"Debuggen"},{"location":"Entwicklung/DebugSerial/#debug-uber-die-serielle-schnittstelle","text":"Wenn man den ESP8266 \u00fcber ein USB-Kabel mit dem Computer verbindet, kann auf dem ESP8266 \u00fcber die serielle Schnittstelle zugegriffen werden. Als Baudrate ist 115200 einzustellen. Im laufenden Betrieb werden zum einen die Logmeldeungen \u00fcber die serielle Schnittstelle ausgegeben, zum anderen stehen verschiedene Befehle im Debugmodus zur Verf\u00fcgung. Der Debugsmodus wird durch das Senden der Zeichenfolge 'debug' aktiviert. Anschlie\u00dfend k\u00f6nnen die Befehle \u00fcber einzelne Buchstaben ausgel\u00f6st werdem. Gro\u00df- und Kleinschreibung sind relevant. Folgende Befehle sind implementiert: 'd': Zeigt diverse Informationen \u00fcber den ESP8266 inkl. Speicher und Wifi-Status an. 'r': Startet den ESP8266 neu. Dieser Weg funktioniert nicht, wenn der ESP8266 gerade neu geflasht wurde. 'D': l\u00f6scht das aktuelle Konfig-File. Nach dem Neustarten des ESP8266 ist er wieder \u00fcber das WLAN-Netz \"Hallo World\" und der IP-Adresse 192.168.4.1 erreichbar. 'a': Aktiviert den AccessPoint-Modus unabh\u00e4ngig vom Konfig-File. Die genutzte IP-Adresse kann \u00fcber die 'd'-Funktion angezeigt werden. 'c': Anzeige des Konfig-Files","title":"Debug \u00fcber die serielle Schnittstelle"},{"location":"Entwicklung/Entwicklung Arduino/","text":"ArduinoIDE Auf der Arduino Webseite gibt es eine Installationsanleitung . Bitte beachtet, dass auch Java installiert sein muss. ESP8266 hinzuf\u00fcgen Das die ArduinoIDE standardm\u00e4\u00dfg nicht kennt, muss der esp8266 gem\u00e4\u00df dieser Anleitung hinzugef\u00fcgt werden. Projekt auschecken TODO Projekt \u00f6ffnen \u00dcber \"Datei/\u00d6ffnen\" kann das Projekt geladen werden, in dem die Datei littleyoda-DCC-Decoder.ino in dem entsprechenden Verzeichnis ausgew\u00e4hlt wird. Einstellungen Unter \"Werkzeuge/Board\" muss das passende ESP8266 ausgew\u00e4hlt werden \u00dcberpr\u00fcfen und Hochladen \u00dcber das H\u00e4kchen-Symbol kann das Programm zum ersten mal kompiliert werden. Dieser Vorgang kann je nach Rechner schon eine Minute dauern. Sollte der Prozess erfolgreich gewesen sein, erscheint im unteren Drittel des Fensters die Meldung \"Kompilieren abgeschlossen\". \u00dcber das \"Pfeil-nach-Rechts\"-Symbol kann das Programm auf das ESP8266 Board \u00fcbertragen werden.","title":"Nutzung Arduino"},{"location":"Entwicklung/Entwicklung Arduino/#arduinoide","text":"Auf der Arduino Webseite gibt es eine Installationsanleitung . Bitte beachtet, dass auch Java installiert sein muss.","title":"ArduinoIDE"},{"location":"Entwicklung/Entwicklung Arduino/#esp8266-hinzufugen","text":"Das die ArduinoIDE standardm\u00e4\u00dfg nicht kennt, muss der esp8266 gem\u00e4\u00df dieser Anleitung hinzugef\u00fcgt werden.","title":"ESP8266 hinzuf\u00fcgen"},{"location":"Entwicklung/Entwicklung Arduino/#projekt-auschecken","text":"TODO","title":"Projekt auschecken"},{"location":"Entwicklung/Entwicklung Arduino/#projekt-offnen","text":"\u00dcber \"Datei/\u00d6ffnen\" kann das Projekt geladen werden, in dem die Datei littleyoda-DCC-Decoder.ino in dem entsprechenden Verzeichnis ausgew\u00e4hlt wird.","title":"Projekt \u00f6ffnen"},{"location":"Entwicklung/Entwicklung Arduino/#einstellungen","text":"Unter \"Werkzeuge/Board\" muss das passende ESP8266 ausgew\u00e4hlt werden","title":"Einstellungen"},{"location":"Entwicklung/Entwicklung Arduino/#uberprufen-und-hochladen","text":"\u00dcber das H\u00e4kchen-Symbol kann das Programm zum ersten mal kompiliert werden. Dieser Vorgang kann je nach Rechner schon eine Minute dauern. Sollte der Prozess erfolgreich gewesen sein, erscheint im unteren Drittel des Fensters die Meldung \"Kompilieren abgeschlossen\". \u00dcber das \"Pfeil-nach-Rechts\"-Symbol kann das Programm auf das ESP8266 Board \u00fcbertragen werden.","title":"\u00dcberpr\u00fcfen und Hochladen"},{"location":"Entwicklung/Entwicklung Eclipse/","text":"Eclipse Eclipse mit Sloeber Java installieren Eclipse mit Sloeber installieren Fertige Pakete zum installieren: Linux Windows Eclipse f\u00fcr den esp8266 konfiguieren Eclipse starten Windows/Preferences In dem Preferences-Dialog unter \"Arduino/Platforms and Boards\" die Option \"esp8266/esp8266/2.3.0\" ausw\u00e4hlen und Apply klicken In dem Preferences-Dialog unter \"Arduino/Library Mangeer\" folgende Libraries ausw\u00e4hlen und Apply klicken Libary Version ArduinoJson 5.11.1 LinkedList 1.2.3 Adafruit_MCP23017 1.0.1 Diese Versionen geben den letzten erfolgreich getesteten Stand an. Neue Versionen werden wahrscheinlich auch funktionieren, aber sie sind nicht getestet. Projekt auschecken TODO Projekteinstellungen Projekt ausw\u00e4hlen Unter Properties: \"C/C++ General\" \"Paths and Symbols\" Tab \"Source Location\" Ersten Eintrag ausw\u00e4hlen \"Edit Filter\" Und \u00fcber ADD, den folgenden Eintrag hinzuf\u00fcgen \"libraries/ArduinoJson/fuzzing/\" Unter Arduino/\"Add a library to the selected Projekt Hier m\u00fcssen die folgenden Library aktiviert werden:","title":"Nutzung Eclipse"},{"location":"Entwicklung/Entwicklung Eclipse/#eclipse","text":"","title":"Eclipse"},{"location":"Entwicklung/Entwicklung Eclipse/#eclipse-mit-sloeber","text":"Java installieren Eclipse mit Sloeber installieren Fertige Pakete zum installieren: Linux Windows","title":"Eclipse mit Sloeber"},{"location":"Entwicklung/Entwicklung Eclipse/#eclipse-fur-den-esp8266-konfiguieren","text":"Eclipse starten Windows/Preferences In dem Preferences-Dialog unter \"Arduino/Platforms and Boards\" die Option \"esp8266/esp8266/2.3.0\" ausw\u00e4hlen und Apply klicken In dem Preferences-Dialog unter \"Arduino/Library Mangeer\" folgende Libraries ausw\u00e4hlen und Apply klicken Libary Version ArduinoJson 5.11.1 LinkedList 1.2.3 Adafruit_MCP23017 1.0.1 Diese Versionen geben den letzten erfolgreich getesteten Stand an. Neue Versionen werden wahrscheinlich auch funktionieren, aber sie sind nicht getestet.","title":"Eclipse f\u00fcr den esp8266 konfiguieren"},{"location":"Entwicklung/Entwicklung Eclipse/#projekt-auschecken","text":"TODO","title":"Projekt auschecken"},{"location":"Entwicklung/Entwicklung Eclipse/#projekteinstellungen","text":"Projekt ausw\u00e4hlen Unter Properties: \"C/C++ General\" \"Paths and Symbols\" Tab \"Source Location\" Ersten Eintrag ausw\u00e4hlen \"Edit Filter\" Und \u00fcber ADD, den folgenden Eintrag hinzuf\u00fcgen \"libraries/ArduinoJson/fuzzing/\" Unter Arduino/\"Add a library to the selected Projekt Hier m\u00fcssen die folgenden Library aktiviert werden:","title":"Projekteinstellungen"},{"location":"Entwicklung/Entwicklungsumgebung/","text":"Sofern euch die fertig kompilierten Dateien nicht reichen oder ihr selber entwickelt m\u00f6chtet, ben\u00f6tigt ihr eine Entwicklungsumgebung. Die ArduinoIDE reicht f\u00fcr das kompilieren dieses Frameworks zwar aus, wirklich Spa\u00df damit ein Projekt dieser Gr\u00f6\u00dfe zu bearbeiten macht es aber nicht. Zwischenzeitlich habe ich Eclipse aus Entwicklungsumgebung empfohlen. Leider ist die Nutzung von Libaries in verschiedenen Versionen unter Eclipse schwierig, so dass ich mittlerweile PlatformIO empfehle.","title":"Entwicklungsumgebung"},{"location":"Entwicklung/Framework/","text":"Framework Den Aufbau des Framework verdeutlich diese Grafik: Die einzelnen Komponenten werden durch Klassen repr\u00e4sentiert. Die Nutzung von Klassen erlaubt die relativ einfache Erweiterung des Frameworks.","title":"Framework"},{"location":"Entwicklung/Framework/#framework","text":"Den Aufbau des Framework verdeutlich diese Grafik: Die einzelnen Komponenten werden durch Klassen repr\u00e4sentiert. Die Nutzung von Klassen erlaubt die relativ einfache Erweiterung des Frameworks.","title":"Framework"},{"location":"Entwicklung/Funktionsumfang/","text":"Der Funktionsumfang h\u00e4ngt nat\u00fcrlich prim\u00e4r von der genutzten Hardware ab. Im Prinzip wird aber folgendes unterst\u00fctzt: Quelle Befehle k\u00f6nnen, je nach Hardware, \u00fcber die folgenden Wege empfangen werden: klassisch \u00fcber ein DCC-Signal (Schaltung mit Optokoppler ist notwendig) z21-Zentrale drahtlos \u00fcber WLAN. Hierbei spielt es keine Rolle, wie die z/Z21 angesteuert wird (Z21-App, Multimaus, WLAN Maus, ...). Der Decoer kommuniziert mit der z/Z21 via WLAN und erh\u00e4lt so den aktuellen Zustand der Loks und Weichen. \u00dcber die WLAN-Maus oder \u00fcber die Z21-App ohne(!) z21-Zentrale. Hierbei simuliert der esp8266 eine z21 und die WLAN-Maus oder die Z21-App kommuniziert direkt mit dem Decoder. Webbrowser drahtlos via WLAN Rudiment\u00e4re Unterst\u00fctzung \u00fcber jeden aktuellen Browser Rocrail Nutzung von Rocrail als Zentrale Andere Zentralen, die \u00fcber einen Netzwerkanschluss verf\u00fcgen, k\u00f6nnen relativ einfach hinzugef\u00fcgt werden. Hierzu muss eine Klasse analog zur Klasse CmdReceiverZ21Wlan implementiert werden. Aktoren Ansteuerung von Weichenmotoren Hiermit k\u00f6nnen die klassischen LGB oder PIKO Weichenmotoren angesteuert werden. Notwendig ist hierbei eine H-Bridge, wie z.B. L293D notwendig LED Zur Zeit nur an oder aus. Hierbei ist ein Transistor oder \u00e4hnliches notwendig, da der esp8266 nicht auf ein direktes anschlie\u00dfen der LED ausgelegt ist. Servo Ansteuerung von Servos. Keine spezielle Hardware notwendig DC Motoren Ansteuerung von Motoren via PWM-Signal. Hierbei ist eine H-Bridge notwendig DCC Signal Generator Hierbei wird ein DCC-Signal generiert; der ESP8266 verwandelt sich somit in eine kleine Art Minizentrale, die komplett in einem Zug eingebaut werden kann. Mit der Kombination Akku, ESP8266, H-Bridge und DCC-Decoder kann man einen autonomen Zug bauen, der weiterhin alle Vorz\u00fcge eines DCC-Decoders (z.B. Soundausgabe) bietet.","title":"Funktionsumfang"},{"location":"Entwicklung/Funktionsumfang/#quelle","text":"Befehle k\u00f6nnen, je nach Hardware, \u00fcber die folgenden Wege empfangen werden: klassisch \u00fcber ein DCC-Signal (Schaltung mit Optokoppler ist notwendig) z21-Zentrale drahtlos \u00fcber WLAN. Hierbei spielt es keine Rolle, wie die z/Z21 angesteuert wird (Z21-App, Multimaus, WLAN Maus, ...). Der Decoer kommuniziert mit der z/Z21 via WLAN und erh\u00e4lt so den aktuellen Zustand der Loks und Weichen. \u00dcber die WLAN-Maus oder \u00fcber die Z21-App ohne(!) z21-Zentrale. Hierbei simuliert der esp8266 eine z21 und die WLAN-Maus oder die Z21-App kommuniziert direkt mit dem Decoder. Webbrowser drahtlos via WLAN Rudiment\u00e4re Unterst\u00fctzung \u00fcber jeden aktuellen Browser Rocrail Nutzung von Rocrail als Zentrale Andere Zentralen, die \u00fcber einen Netzwerkanschluss verf\u00fcgen, k\u00f6nnen relativ einfach hinzugef\u00fcgt werden. Hierzu muss eine Klasse analog zur Klasse CmdReceiverZ21Wlan implementiert werden.","title":"Quelle"},{"location":"Entwicklung/Funktionsumfang/#aktoren","text":"Ansteuerung von Weichenmotoren Hiermit k\u00f6nnen die klassischen LGB oder PIKO Weichenmotoren angesteuert werden. Notwendig ist hierbei eine H-Bridge, wie z.B. L293D notwendig LED Zur Zeit nur an oder aus. Hierbei ist ein Transistor oder \u00e4hnliches notwendig, da der esp8266 nicht auf ein direktes anschlie\u00dfen der LED ausgelegt ist. Servo Ansteuerung von Servos. Keine spezielle Hardware notwendig DC Motoren Ansteuerung von Motoren via PWM-Signal. Hierbei ist eine H-Bridge notwendig DCC Signal Generator Hierbei wird ein DCC-Signal generiert; der ESP8266 verwandelt sich somit in eine kleine Art Minizentrale, die komplett in einem Zug eingebaut werden kann. Mit der Kombination Akku, ESP8266, H-Bridge und DCC-Decoder kann man einen autonomen Zug bauen, der weiterhin alle Vorz\u00fcge eines DCC-Decoders (z.B. Soundausgabe) bietet.","title":"Aktoren"},{"location":"Erkl\u00e4rungen/H-Bridge/","text":"H-Bridge Eine H-Bridge dient der Ansteuerung von Gleichstorm-Motoren. Vereinfacht ausgedr\u00fcckt sorgt sie daf\u00fcr, dass die Polarit\u00e4t umgekehrt werden kann, der Motor sich also vorw\u00e4rts und r\u00fcckw\u00e4rts drehen kann. In Rahmen dieses Projektes, habe ich mit folgenden H-Bridges \"gespielt\": Chips L293D Ist f\u00fcr 0,6A (1,2A Peak) ausgelegt. Ich nutze sie f\u00fcr meinen Weichendekoder. Mit 50 Cent (*) unschlagbar billigt, aber der Chip verzeiht keine Fehler. Wenn die Ausg\u00e4nge etwas zu lange aktiv sind, gibt sie schon mal Rauchzeichen von sich. DRV8870 Diese H-Bridge ist f\u00fcr 2A (3,6A Peak) ausgelegt. Ich nutze sie f\u00fcr meinen Lokdekoder. Mit einem Preis von knapp 2\u20ac nicht ganz so preiswert. Als SMD-Bauteil ist der Chip nicht einfach zu l\u00f6ten. Die gr\u00f6\u00dfte Herausforderung ist, dass es unter dem Chip eine Metallfl\u00e4che gibt, die f\u00fcr die W\u00e4rmeableitung zust\u00e4ndig ist und normalerweise auf die Platine gel\u00f6tet werden muss. Dieses ist jedoch mit Hobbymitteln nicht wirklich m\u00f6glich. Fertige Platinen L298N Diese Platine wurde im Test des DCC-Signal-Generators genutzt und trieb erfolgreichen einen Playmobil-Motorblock an. BTS7960 Diese Platine habe ich im Lokdekoder f\u00fcr eine Piko-Lok mit zwei Motoren genutzt.","title":"H-Bridge"},{"location":"Erkl\u00e4rungen/H-Bridge/#h-bridge","text":"Eine H-Bridge dient der Ansteuerung von Gleichstorm-Motoren. Vereinfacht ausgedr\u00fcckt sorgt sie daf\u00fcr, dass die Polarit\u00e4t umgekehrt werden kann, der Motor sich also vorw\u00e4rts und r\u00fcckw\u00e4rts drehen kann. In Rahmen dieses Projektes, habe ich mit folgenden H-Bridges \"gespielt\":","title":"H-Bridge"},{"location":"Erkl\u00e4rungen/H-Bridge/#chips","text":"","title":"Chips"},{"location":"Erkl\u00e4rungen/H-Bridge/#l293d","text":"Ist f\u00fcr 0,6A (1,2A Peak) ausgelegt. Ich nutze sie f\u00fcr meinen Weichendekoder. Mit 50 Cent (*) unschlagbar billigt, aber der Chip verzeiht keine Fehler. Wenn die Ausg\u00e4nge etwas zu lange aktiv sind, gibt sie schon mal Rauchzeichen von sich.","title":"L293D"},{"location":"Erkl\u00e4rungen/H-Bridge/#drv8870","text":"Diese H-Bridge ist f\u00fcr 2A (3,6A Peak) ausgelegt. Ich nutze sie f\u00fcr meinen Lokdekoder. Mit einem Preis von knapp 2\u20ac nicht ganz so preiswert. Als SMD-Bauteil ist der Chip nicht einfach zu l\u00f6ten. Die gr\u00f6\u00dfte Herausforderung ist, dass es unter dem Chip eine Metallfl\u00e4che gibt, die f\u00fcr die W\u00e4rmeableitung zust\u00e4ndig ist und normalerweise auf die Platine gel\u00f6tet werden muss. Dieses ist jedoch mit Hobbymitteln nicht wirklich m\u00f6glich.","title":"DRV8870"},{"location":"Erkl\u00e4rungen/H-Bridge/#fertige-platinen","text":"","title":"Fertige Platinen"},{"location":"Erkl\u00e4rungen/H-Bridge/#l298n","text":"Diese Platine wurde im Test des DCC-Signal-Generators genutzt und trieb erfolgreichen einen Playmobil-Motorblock an.","title":"L298N"},{"location":"Erkl\u00e4rungen/H-Bridge/#bts7960","text":"Diese Platine habe ich im Lokdekoder f\u00fcr eine Piko-Lok mit zwei Motoren genutzt.","title":"BTS7960"},{"location":"Hardware/DCC-Decoder/","text":"Basisschaltung f\u00fcr einen DCC-Decoder","title":"DCC-Generator"},{"location":"Nutzung/Erste-Schritte/","text":"Erste Schritte Die Seite soll euch bei den ersten Schritten unterst\u00fctzen. Hardware F\u00fcr die ersten Schritte, ben\u00f6tigt ihr eine ESP8266-Platine und ein passenden USB-Kabel. Ich empfehle entweder den Nodemcu V2(*) oder den D1 Mini(*) , die f\u00fcr wenige Euros in Asien bestellt werden k\u00f6nnen. Je nach Verwendungszweck sind die Platinen mal auf den Nodemcu und mal auf den D1 Mini oder auf ein anderes Modell auslegt. Software Sofern ihr nicht selber am Framework entwickelt wollt, braucht ihr zum einen ein Programm zu Flashen (also zum \u00dcbertragen des Codes auf den ESP8266) und ein Programm mit dem ihr die Debug-Ausgabe des Boards euch anzeigen lassen kann. Zum Flashen kann der NodeMCU-flasher genutzt werden. Download: Windows 32 , Windows 64 F\u00fcr den Zugriff auf die Debug-Ausgaben kann Putty genutzt werden: Download Das eigentliche Programm (BIN-Datei), die Firmware, welche mit Hilfe des Flash-Programmes auf den ESP8266 \u00fcbertragen wird, kann man mit gen\u00fcgend Vorwissen selber kompilieren oder einfacher heruntergeladen werden. Au\u00dferdem werden noch die beiden Dateien css.css und milligram.min.css ben\u00f6tigt, die hier heruntergeladen werden k\u00f6nnen. Flashen Nur das ESP8266-Board (ohne weitere Platinen oder \u00e4hnliches) wird an den Rechner angeschlossen und anschlie\u00dfend NodeMCU-Flasher gestartet. Nach dem Starten muss als erstes die richtige BIN-Datei ausgew\u00e4hlt werden: Danach kann mit dem Flashen begonnen werden, in dem auf den \"Flash\"-Button geklickt wird. Wenn das Flashen erfolgreich durchgef\u00fchrt wurde, solltet ihr folgende Meldung sehen (MAC-Adresse k\u00f6nnen nat\u00fcrlich abweichen): Wartet nach dem ersten erfolgreichen Flashen erstmal knapp eine halbe Minute ab. In dieser Zeit formatiert der ESP8266 seinen eingebauten Datenspeicher. Erste Kontaktaufnahme Die erste Kontaktaufnahme erfolgt \u00fcber WLAN. Nachdem der ESP8266 fertig ist und ggf. einmal neu gestartet wurde (USB-Kabel raus/rein), sollte er ein eigenes WLAN mit dem Namen \"HALLO WORLD\" aufspannen. Verbindet euch bitte mit diesem WLAN und gebt in einem Browser die folgende Adresse ein \"192.168.4.1\". Danach solltet ihr eine Webseite der folgenden Art sehen: Anschlie\u00dfend m\u00fcssen die Dateien css.css und milligram.min.css hochgeladen werden. Hierzu muss das Ordnersymbol angeklickt werden: Anschlie\u00dfend f\u00fcr beide Dateien jeweils einmal auf \"Datei ausw\u00e4hlen\" klicken, die entsprechende Datei ausw\u00e4hlen und auf \"Send\" klicken. Die Hauptseite \"192.168.4.1\" sollte anschlie\u00dfend so aussehen: Kontaktaufnahme \u00fcber die serielle Schnittstelle Um bei evtl. Problemen vorbereitet zu sein, solltet ihr jetzt versuchen, \u00fcber Putty eine Verbindung zum ESP8266 aufzubauen. TODO: Ausf\u00fchrliche Erkl\u00e4rung; 115200 Baud, Wenn man ein d in Putty sendet, sollten Debug Informationen angezeigt werden Weitere Informationen \u00fcber die Debug-Schnittstelle finden sich hier Konfigurieren In diesem Zustand kann der ESP8266 noch nicht viel. Als n\u00e4chstes muss die Konfigurations-Datei hochgeladen werden. Die Konfiguration ist von dem Einsatzzweck abh\u00e4ngig. Die jeweilige Konfigurationsdatei (config.json) muss dann analog zu den css.css und milligram.min.css hochgeladen werden. Anschlie\u00dfend muss der Prozessor neu gestartet werden.","title":"Erste Schritte"},{"location":"Nutzung/Erste-Schritte/#erste-schritte","text":"Die Seite soll euch bei den ersten Schritten unterst\u00fctzen.","title":"Erste Schritte"},{"location":"Nutzung/Erste-Schritte/#hardware","text":"F\u00fcr die ersten Schritte, ben\u00f6tigt ihr eine ESP8266-Platine und ein passenden USB-Kabel. Ich empfehle entweder den Nodemcu V2(*) oder den D1 Mini(*) , die f\u00fcr wenige Euros in Asien bestellt werden k\u00f6nnen. Je nach Verwendungszweck sind die Platinen mal auf den Nodemcu und mal auf den D1 Mini oder auf ein anderes Modell auslegt.","title":"Hardware"},{"location":"Nutzung/Erste-Schritte/#software","text":"Sofern ihr nicht selber am Framework entwickelt wollt, braucht ihr zum einen ein Programm zu Flashen (also zum \u00dcbertragen des Codes auf den ESP8266) und ein Programm mit dem ihr die Debug-Ausgabe des Boards euch anzeigen lassen kann. Zum Flashen kann der NodeMCU-flasher genutzt werden. Download: Windows 32 , Windows 64 F\u00fcr den Zugriff auf die Debug-Ausgaben kann Putty genutzt werden: Download Das eigentliche Programm (BIN-Datei), die Firmware, welche mit Hilfe des Flash-Programmes auf den ESP8266 \u00fcbertragen wird, kann man mit gen\u00fcgend Vorwissen selber kompilieren oder einfacher heruntergeladen werden. Au\u00dferdem werden noch die beiden Dateien css.css und milligram.min.css ben\u00f6tigt, die hier heruntergeladen werden k\u00f6nnen.","title":"Software"},{"location":"Nutzung/Erste-Schritte/#flashen","text":"Nur das ESP8266-Board (ohne weitere Platinen oder \u00e4hnliches) wird an den Rechner angeschlossen und anschlie\u00dfend NodeMCU-Flasher gestartet. Nach dem Starten muss als erstes die richtige BIN-Datei ausgew\u00e4hlt werden: Danach kann mit dem Flashen begonnen werden, in dem auf den \"Flash\"-Button geklickt wird. Wenn das Flashen erfolgreich durchgef\u00fchrt wurde, solltet ihr folgende Meldung sehen (MAC-Adresse k\u00f6nnen nat\u00fcrlich abweichen): Wartet nach dem ersten erfolgreichen Flashen erstmal knapp eine halbe Minute ab. In dieser Zeit formatiert der ESP8266 seinen eingebauten Datenspeicher.","title":"Flashen"},{"location":"Nutzung/Erste-Schritte/#erste-kontaktaufnahme","text":"Die erste Kontaktaufnahme erfolgt \u00fcber WLAN. Nachdem der ESP8266 fertig ist und ggf. einmal neu gestartet wurde (USB-Kabel raus/rein), sollte er ein eigenes WLAN mit dem Namen \"HALLO WORLD\" aufspannen. Verbindet euch bitte mit diesem WLAN und gebt in einem Browser die folgende Adresse ein \"192.168.4.1\". Danach solltet ihr eine Webseite der folgenden Art sehen: Anschlie\u00dfend m\u00fcssen die Dateien css.css und milligram.min.css hochgeladen werden. Hierzu muss das Ordnersymbol angeklickt werden: Anschlie\u00dfend f\u00fcr beide Dateien jeweils einmal auf \"Datei ausw\u00e4hlen\" klicken, die entsprechende Datei ausw\u00e4hlen und auf \"Send\" klicken. Die Hauptseite \"192.168.4.1\" sollte anschlie\u00dfend so aussehen:","title":"Erste Kontaktaufnahme"},{"location":"Nutzung/Erste-Schritte/#kontaktaufnahme-uber-die-serielle-schnittstelle","text":"Um bei evtl. Problemen vorbereitet zu sein, solltet ihr jetzt versuchen, \u00fcber Putty eine Verbindung zum ESP8266 aufzubauen. TODO: Ausf\u00fchrliche Erkl\u00e4rung; 115200 Baud, Wenn man ein d in Putty sendet, sollten Debug Informationen angezeigt werden Weitere Informationen \u00fcber die Debug-Schnittstelle finden sich hier","title":"Kontaktaufnahme \u00fcber die serielle Schnittstelle"},{"location":"Nutzung/Erste-Schritte/#konfigurieren","text":"In diesem Zustand kann der ESP8266 noch nicht viel. Als n\u00e4chstes muss die Konfigurations-Datei hochgeladen werden. Die Konfiguration ist von dem Einsatzzweck abh\u00e4ngig. Die jeweilige Konfigurationsdatei (config.json) muss dann analog zu den css.css und milligram.min.css hochgeladen werden. Anschlie\u00dfend muss der Prozessor neu gestartet werden.","title":"Konfigurieren"},{"location":"Nutzung/Firmware-Updates/","text":"Sollte irgendwann mal der Bedarf bestehen die Software, die auf dem ESP8266 l\u00e4uft, zu aktualisieren, braucht man nicht den Weg zu beschreiten, der unter Erste Schritte erkl\u00e4rt war, vielmehr kann die Firmware direkt \u00fcber einen Browser aktualisiert werden. Die hochgeladenen Dateien (config.json, CSS-Datein) bleiben bei diesem Prozess unver\u00e4ndert! Folgende Schritte sind notwendig: - Download der aktuellen Firmware (Bin-Datei) - \u00dcber einen Browser auf den ESP826 zugreifen - http://ip-addr/firmware also z.B. http://192.168.0.111/firmware - Sofern die Zugangsdaten in den Sourcen nicht ge\u00e4ndert wurden, lauten der Username admin und das Password ebenfalls admin - Auf Durchsuchen klicken und die Bin-Datei ausw\u00e4hlen - Anschlie\u00dfend auf Update klicken - ca. 30 Sekunden warten - Anschlie\u00dfend sollte man den Firmware Stand unter http://ip-addr/log pr\u00fcfen. Nur wenn dieser Ansatz nicht funktioniert, muss man auf den Weg \u00fcber das Flash-Programm zur\u00fcckgreifen.","title":"Firmware Updates"},{"location":"old/Platinen/","text":"Ein Hinweis vorab: Fertige Dekoder oder Baus\u00e4tze biete ich aus rechtlichen Gr\u00fcnden nicht an. Platinen k\u00f6nnt ihr, so lange der Vorrat reicht, bei mir gegen Unkostenbeitrag + Porto erhalten und ich bin gerne bereit euch Bezugsquellen f\u00fcr die einzelnen Bauteile zu nennen, wenn es hier Probleme gibt. Hier einige Beispiele Weichendecoder Ein einfacher Weichendecoder, der zwei Weichenmotoren ansteuern kann. Die Befehle werden entweder per DCC von den Schienen empfangen oder per WLAN von einer Z21. Weitere Informationen Konfigfile Lokdekoder 1 Ein einfacher Lokdekoder, der eine fertige H-Bridge nutzt. Die Befehle werden entweder per DCC von den Schienen empfangen oder per WLAN von einer Z21. Weitere Informationen Lokdekoder (DRV8870) Ein einfacher Lokdekoder, der einen DRV8870 als H-Bridge nutzt. Bedingt durch die Bauform des DRV8870 nicht so ganz einfach zu l\u00f6ten. Mehr Informationen Lokdekoder (BTS7960) ein einfacher Lokdekoder, der eine BTS7960 Platine als H-Bridge nutzt. Mehr Informationen WLAN nach DCC Decoder Ein Deocder, der ein DCC Signal generiert, mit denen klassische DCC-Decoder betrieben werden kann. Sinnvoll, wenn man auf die Funktionalit\u00e4t von klassischen DCC-Decodern (Sound, ...) nicht verzichten will, aber DCC \u00fcber Schienen nicht nutzen will. Mehr Informationen L298N-Bridge DRV8870 Entwicklungsgeschichte Eine \u00dcbersicht \u00fcber die verschiedenen Entwicklungsstr\u00e4nge, die im Laufe der Zeit entstanden sind: Entwicklungsstr\u00e4nge F\u00fcr einige Entwicklungsschritte sind weitere Informationen verlinkt.","title":"Platinen"},{"location":"old/Platinen/#weichendecoder","text":"Ein einfacher Weichendecoder, der zwei Weichenmotoren ansteuern kann. Die Befehle werden entweder per DCC von den Schienen empfangen oder per WLAN von einer Z21. Weitere Informationen Konfigfile","title":"Weichendecoder"},{"location":"old/Platinen/#lokdekoder-1","text":"Ein einfacher Lokdekoder, der eine fertige H-Bridge nutzt. Die Befehle werden entweder per DCC von den Schienen empfangen oder per WLAN von einer Z21. Weitere Informationen","title":"Lokdekoder 1"},{"location":"old/Platinen/#lokdekoder-drv8870","text":"Ein einfacher Lokdekoder, der einen DRV8870 als H-Bridge nutzt. Bedingt durch die Bauform des DRV8870 nicht so ganz einfach zu l\u00f6ten. Mehr Informationen","title":"Lokdekoder (DRV8870)"},{"location":"old/Platinen/#lokdekoder-bts7960","text":"ein einfacher Lokdekoder, der eine BTS7960 Platine als H-Bridge nutzt. Mehr Informationen","title":"Lokdekoder (BTS7960)"},{"location":"old/Platinen/#wlan-nach-dcc-decoder","text":"Ein Deocder, der ein DCC Signal generiert, mit denen klassische DCC-Decoder betrieben werden kann. Sinnvoll, wenn man auf die Funktionalit\u00e4t von klassischen DCC-Decodern (Sound, ...) nicht verzichten will, aber DCC \u00fcber Schienen nicht nutzen will. Mehr Informationen L298N-Bridge DRV8870","title":"WLAN nach DCC Decoder"},{"location":"old/Platinen/#entwicklungsgeschichte","text":"Eine \u00dcbersicht \u00fcber die verschiedenen Entwicklungsstr\u00e4nge, die im Laufe der Zeit entstanden sind: Entwicklungsstr\u00e4nge F\u00fcr einige Entwicklungsschritte sind weitere Informationen verlinkt.","title":"Entwicklungsgeschichte"},{"location":"old/_Footer/","text":"Falls euch Fehler auffallen, k\u00f6nnt ihr die Seiten gerne \u00e4ndern oder mir eine Nachricht mit den Verbesserungsvorschl\u00e4gen oder den ge\u00e4nderten Texten zukommen lassen. Diese Dokumentation ist lizenziert unter einer Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz .","title":" Footer"},{"location":"old/_Sidebar/","text":"Start Erste-Schritte Anwendungsbeispiele * FAQ (H\u00e4ufige Fragen) Betrieb * Firmware-Updates Entwicklungsbereich DebugSerial Entwicklungsumgebung * Framework Sonstiges * Begriff-H-Bridge","title":" Sidebar"}]}